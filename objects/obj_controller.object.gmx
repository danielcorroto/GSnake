<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>0</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>// Comportamiento de la aplicación
os_powersave_enable(false);
randomize();

// Ancho y alto en celdas
cell_width = round(room_width / SNAKE_SIZE);
cell_height = round(room_height / SNAKE_SIZE);

// Mapa de celdas ocupadas
cells = ds_map_create();

// Vidas de cada elemento de la serpiente
lives = 5;
// Si el juego está en funcionamiento
started = false;
// Tiempo de espera para moverse
wait = WAIT_TIME;
// Zona de aparición de la serpiente
xzone = floor(cell_width / 2) - 1;
yzone = floor(cell_height / 2) - 1;
// Ubicación de la fruta
xfruit = -1;
yfruit = -1;
// Dirección de la serpiente
dir = DIR_NO;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (!started) {
    exit;
}

// Reduce la "vida" de cada eslabón de la serpiente
show_debug_message("--");
for (i=0; i&lt;instance_number(obj_snake); i++) {
    inst = instance_find(obj_snake,i);
    inst.live--;
    //show_debug_message(string(i) + " " + string(inst.live));
}
// Elimina el eslabón
for (i=0; i&lt;instance_number(obj_snake); i++) {
    inst = instance_find(obj_snake,i);
    if (inst.live &lt;= 0) {
        cellx = round(inst.x / SNAKE_SIZE);
        celly = round(inst.y / SNAKE_SIZE);
        cellid = celly * cell_width + cellx;
        ds_map_delete(cells, cellid);
        show_debug_message(string(cellid) + " removed");
        with (inst) {
            instance_destroy();
        }
    }
}

// Cálculo de la nueva dirección
dir = scr_next_direction(dir);
if (dir == DIR_UP) yzone--;
else if (dir == DIR_RIGHT) xzone++;
else if (dir == DIR_DOWN) yzone++;
else if (dir == DIR_LEFT) xzone--;

// Comprobación de colisiones
if (scr_eval_collision()) {
    // Muestra el marcador
    instance_create(room_width / 2, room_height / 2, obj_score);
    started = false;
}

// Crea nueva serpiente
cellid = yzone * cell_width + xzone;
ds_map_add(cells, cellid, true);
inst = instance_create(xzone * SNAKE_SIZE, yzone * SNAKE_SIZE, obj_snake);
inst.image_xscale = SNAKE_SIZE / inst.sprite_width;
inst.image_yscale = SNAKE_SIZE / inst.sprite_height;
show_debug_message(string(cellid) + " created");

// Evalúa si consigue la fruta
if (xzone == xfruit and yzone == yfruit) {
    score++;
    xfruit = -1;
    yfruit = -1;
    with(instance_find(obj_fruit, 0)) {
        instance_destroy();
    }
    // Aumenta la vida
    lives += EXTRA_LIVES;
    for (i=0; i&lt;instance_number(obj_snake); i++) {
        inst = instance_find(obj_snake,i);
        inst.live += EXTRA_LIVES;
    }
    // Muestra el marcador
    instance_create(room_width / 2, room_height / 2, obj_score);
}

// Genera una nueva fruta
fruit_option = 0;
if (xfruit == -1) {
    // Busca las celdas vacías
    count = 0;
    for (i=0; i&lt;cell_width; i++) {
        for (j=0; j&lt;cell_height; j++) {
            if (not ds_map_exists(cells, j * cell_width + i)) {
                fruit_option[count] = j * cell_width + i;
                count++;
            }
        }
    }
    // Selecciona una al azar
    fruit_id = irandom(array_length_1d(fruit_option) - 1);
    fruit_cell = fruit_option[fruit_id];
    xfruit = fruit_cell mod cell_width;
    yfruit = fruit_cell div cell_width;
    
    fruit = instance_create(xfruit * SNAKE_SIZE, yfruit * SNAKE_SIZE, obj_fruit);
    fruit.image_xscale = SNAKE_SIZE / fruit.sprite_width;
    fruit.image_yscale = SNAKE_SIZE / fruit.sprite_height;
    fruit.image_index = irandom(image_number - 1);
    fruit.image_speed = 0;
    show_debug_message(string(yfruit * cell_width + xfruit) + " fruit created");
}

alarm_set(0, wait);
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
